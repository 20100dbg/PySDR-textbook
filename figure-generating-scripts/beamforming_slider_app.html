<html>
  <head>
    <style>
      span {
        display: inline-block;
        width: 30px;
      }
    </style>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  </head>
  <body>
    <div id="rectPlot"><!-- Plotly chart will be drawn inside this DIV --></div>

    <script type="text/javascript">
      function FFT(size) {
        this.size = size | 0;
        if (this.size <= 1 || (this.size & (this.size - 1)) !== 0) throw new Error("FFT size must be a power of two and bigger than 1");

        this._csize = size << 1;

        // NOTE: Use of `var` is intentional for old V8 versions
        var table = new Array(this.size * 2);
        for (var i = 0; i < table.length; i += 2) {
          const angle = (Math.PI * i) / this.size;
          table[i] = Math.cos(angle);
          table[i + 1] = -Math.sin(angle);
        }
        this.table = table;

        // Find size's power of two
        var power = 0;
        for (var t = 1; this.size > t; t <<= 1) power++;

        // Calculate initial step's width:
        //   * If we are full radix-4 - it is 2x smaller to give inital len=8
        //   * Otherwise it is the same as `power` to give len=4
        this._width = power % 2 === 0 ? power - 1 : power;

        // Pre-compute bit-reversal patterns
        this._bitrev = new Array(1 << this._width);
        for (var j = 0; j < this._bitrev.length; j++) {
          this._bitrev[j] = 0;
          for (var shift = 0; shift < this._width; shift += 2) {
            var revShift = this._width - shift - 2;
            this._bitrev[j] |= ((j >>> shift) & 3) << revShift;
          }
        }

        this._out = null;
        this._data = null;
        this._inv = 0;
      }

      FFT.prototype.createComplexArray = function createComplexArray() {
        const res = new Array(this._csize);
        for (var i = 0; i < res.length; i++) res[i] = 0;
        return res;
      };

      FFT.prototype.toComplexArray = function toComplexArray(input, storage) {
        var res = storage || this.createComplexArray();
        for (var i = 0; i < res.length; i += 2) {
          res[i] = input[i >>> 1];
          res[i + 1] = 0;
        }
        return res;
      };

      FFT.prototype.transform = function transform(out, data) {
        if (out === data) throw new Error("Input and output buffers must be different");

        this._out = out;
        this._data = data;
        this._inv = 0;
        this._transform4();
        this._out = null;
        this._data = null;
      };

      // radix-4 implementation
      FFT.prototype._transform4 = function _transform4() {
        var out = this._out;
        var size = this._csize;

        // Initial step (permute and transform)
        var width = this._width;
        var step = 1 << width;
        var len = (size / step) << 1;

        var outOff;
        var t;
        var bitrev = this._bitrev;
        if (len === 4) {
          for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
            const off = bitrev[t];
            this._singleTransform2(outOff, off, step);
          }
        } else {
          // len === 8
          for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
            const off = bitrev[t];
            this._singleTransform4(outOff, off, step);
          }
        }

        // Loop through steps in decreasing order
        var inv = this._inv ? -1 : 1;
        var table = this.table;
        for (step >>= 2; step >= 2; step >>= 2) {
          len = (size / step) << 1;
          var quarterLen = len >>> 2;

          // Loop through offsets in the data
          for (outOff = 0; outOff < size; outOff += len) {
            // Full case
            var limit = outOff + quarterLen;
            for (var i = outOff, k = 0; i < limit; i += 2, k += step) {
              const A = i;
              const B = A + quarterLen;
              const C = B + quarterLen;
              const D = C + quarterLen;

              // Original values
              const Ar = out[A];
              const Ai = out[A + 1];
              const Br = out[B];
              const Bi = out[B + 1];
              const Cr = out[C];
              const Ci = out[C + 1];
              const Dr = out[D];
              const Di = out[D + 1];

              // Middle values
              const MAr = Ar;
              const MAi = Ai;

              const tableBr = table[k];
              const tableBi = inv * table[k + 1];
              const MBr = Br * tableBr - Bi * tableBi;
              const MBi = Br * tableBi + Bi * tableBr;

              const tableCr = table[2 * k];
              const tableCi = inv * table[2 * k + 1];
              const MCr = Cr * tableCr - Ci * tableCi;
              const MCi = Cr * tableCi + Ci * tableCr;

              const tableDr = table[3 * k];
              const tableDi = inv * table[3 * k + 1];
              const MDr = Dr * tableDr - Di * tableDi;
              const MDi = Dr * tableDi + Di * tableDr;

              // Pre-Final values
              const T0r = MAr + MCr;
              const T0i = MAi + MCi;
              const T1r = MAr - MCr;
              const T1i = MAi - MCi;
              const T2r = MBr + MDr;
              const T2i = MBi + MDi;
              const T3r = inv * (MBr - MDr);
              const T3i = inv * (MBi - MDi);

              // Final values
              const FAr = T0r + T2r;
              const FAi = T0i + T2i;

              const FCr = T0r - T2r;
              const FCi = T0i - T2i;

              const FBr = T1r + T3i;
              const FBi = T1i - T3r;

              const FDr = T1r - T3i;
              const FDi = T1i + T3r;

              out[A] = FAr;
              out[A + 1] = FAi;
              out[B] = FBr;
              out[B + 1] = FBi;
              out[C] = FCr;
              out[C + 1] = FCi;
              out[D] = FDr;
              out[D + 1] = FDi;
            }
          }
        }
      };

      // radix-4
      FFT.prototype._singleTransform4 = function _singleTransform4(outOff, off, step) {
        const out = this._out;
        const data = this._data;
        const inv = this._inv ? -1 : 1;
        const step2 = step * 2;
        const step3 = step * 3;

        // Original values
        const Ar = data[off];
        const Ai = data[off + 1];
        const Br = data[off + step];
        const Bi = data[off + step + 1];
        const Cr = data[off + step2];
        const Ci = data[off + step2 + 1];
        const Dr = data[off + step3];
        const Di = data[off + step3 + 1];

        // Pre-Final values
        const T0r = Ar + Cr;
        const T0i = Ai + Ci;
        const T1r = Ar - Cr;
        const T1i = Ai - Ci;
        const T2r = Br + Dr;
        const T2i = Bi + Di;
        const T3r = inv * (Br - Dr);
        const T3i = inv * (Bi - Di);

        // Final values
        const FAr = T0r + T2r;
        const FAi = T0i + T2i;

        const FBr = T1r + T3i;
        const FBi = T1i - T3r;

        const FCr = T0r - T2r;
        const FCi = T0i - T2i;

        const FDr = T1r - T3i;
        const FDi = T1i + T3r;

        out[outOff] = FAr;
        out[outOff + 1] = FAi;
        out[outOff + 2] = FBr;
        out[outOff + 3] = FBi;
        out[outOff + 4] = FCr;
        out[outOff + 5] = FCi;
        out[outOff + 6] = FDr;
        out[outOff + 7] = FDi;
      };

      // FFT Shift
      function rotate(src, n) {
        var len = src.length;
        reverse(src, 0, len);
        reverse(src, 0, n);
        reverse(src, n, len);
        return src;
      }
      function reverse(src, from, to) {
        --from;
        while (++from < --to) {
          var tmp = src[from];
          src[from] = src[to];
          src[to] = tmp;
        }
      }
      function fftshift(src) {
        return rotate(src, Math.floor(src.length / 2));
      }

      // Init FFT
      const fftsize = 1024;
      const f = new FFT(fftsize);
      const input = new Array(fftsize * 2);
      const out = f.createComplexArray();

      // Map the FFT bins to angles in radians, in python its np.arcsin(np.linspace(-1, 1, fftsize))
      let bins = Array.from({ length: fftsize }, (v, k) => k + 1);
      bins = bins.map((x) => (x - fftsize / 2) / (fftsize / 2));
      bins = bins.map((x) => Math.asin(x));
      bins = bins.map((x) => (x * 180) / Math.PI); // convert from radians to degrees
      bins = bins.map((x) => x * 3); // for some reason i needed to add this to zoom in, or else we get way more sidelobes than expected

      // Plotly
      var trace1 = {
        x: bins,
        y: Array.from({ length: fftsize }, (v, k) => k + 1),
        type: "scatter"
      };

      var data = [trace1];

      var layout = {
        autosize: false,
        width: 350,
        height: 200,
        margin: {
          l: 30,
          r: 0,
          b: 40,
          t: 0,
          pad: 0
        },
        paper_bgcolor: "white",
        plot_bgcolor: "white",
        xaxis: {
          gridcolor: "black",
          dtick: 100,
          range: [-90, 90]
        },
        yaxis: {
          gridcolor: "black",
          dtick: 5,
          range: [-40, 10]
        }
      };

      Plotly.newPlot("rectPlot", data, layout);

      function calculate_beam_pattern() {
        input.fill(0);
        for (var i = 0; i < 8; i++) {
          input[i * 2] = document.getElementById("mag" + i).value * Math.cos(document.getElementById("phase" + i).value);
          input[i * 2 + 1] = document.getElementById("mag" + i).value * Math.sin(document.getElementById("phase" + i).value) * -1; // complex conjugate each value
        }

        // FFT
        f.transform(out, f.toComplexArray(input));

        // Calculate magnitude
        let fftmag = new Array(fftsize);
        for (var i = 0; i < fftsize; i++) {
          fftmag[i] = Math.sqrt(out[i * 2] * out[i * 2] + out[i * 2 + 1] * out[i * 2 + 1]);
        }

        // Square the signal
        for (var i = 0; i < fftsize; i++) {
          fftmag[i] = fftmag[i] * fftmag[i];
        }

        fftmag = fftshift(fftmag);

        // Convert to dB and apply scaling factor
        for (var i = 0; i < fftsize; i++) {
          fftmag[i] = 10 * Math.log10(fftmag[i]) - 10; // scaling factor to make peak at 9 dB (8 linear)
        }
        return fftmag;
      }

      for (var i = 0; i < 8; i++) {
        var span = document.createElement("span");
        span.append(String(i));
        document.body.appendChild(span);

        var mag = document.createElement("input");
        mag.type = "range";
        mag.className = "slider";
        mag.value = "1";
        mag.min = "0";
        mag.max = "1";
        mag.step = "0.01";
        mag.id = "mag" + i;
        document.body.appendChild(mag);

        var span_mag = document.createElement("span");
        span_mag.id = "mag" + i + "_label";
        span_mag.textContent = 1;
        document.body.appendChild(span_mag);

        // Make slider change label
        document.getElementById("mag" + i).addEventListener("input", function () {
          document.getElementById(this.id + "_label").textContent = Math.round(this.value * 100) / 100;
          data[0]["y"] = calculate_beam_pattern();
          Plotly.redraw("rectPlot");
        });

        var phase = document.createElement("input");
        phase.type = "range";
        phase.className = "slider";
        phase.value = "0";
        phase.min = "-3.14159";
        phase.max = "3.14159";
        phase.step = "0.01";
        phase.id = "phase" + i;
        document.body.appendChild(phase);

        var span = document.createElement("span");
        span.id = "phase" + i + "_label";
        span.textContent = 0;
        document.body.appendChild(span);

        // Make slider change label
        document.getElementById("phase" + i).addEventListener("input", function () {
          document.getElementById(this.id + "_label").textContent = Math.round(this.value * 100) / 100;
          data[0]["y"] = calculate_beam_pattern();
          Plotly.redraw("rectPlot");
        });

        var br = document.createElement("br");
        document.body.appendChild(br);
      }

      // Add reset button
      var reset = document.createElement("button");
      reset.textContent = "Reset";
      reset.onclick = function () {
        for (var i = 1; i < 9; i++) {
          document.getElementById("mag" + i).value = 1;
          document.getElementById("mag" + i + "_label").textContent = 1;
          document.getElementById("phase" + i).value = 0;
          document.getElementById("phase" + i + "_label").textContent = 0;
        }
      };
      document.body.appendChild(reset);

      // Run processing once
      data[0]["y"] = calculate_beam_pattern();
      Plotly.redraw("rectPlot");
    </script>
  </body>
</html>
